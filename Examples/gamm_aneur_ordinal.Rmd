---
title: "aneur: comparando stan y cgam"
output: 
  pdf_document: 
    latex_engine: xelatex
    keep_tex: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\url{https://mc-stan.org/docs/2_18/stan-users-guide/ordered-logistic-section.html}

```{R, eval=TRUE, fig.show="hold", echo=FALSE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}

library(VGAM)
library(mgcv)
library(rstan)
library(rjags)
load.module("glm")
library(plot3D)
library(dplyr)
library(ggplot2)
library(corrplot)
library(splines)
library(splines2)
library(cgam)
library(MASS)
library(msm)
library(nlme)
library(ordinal)

rstan_options(auto_write = TRUE)
setwd("/Users/lizbethna/Documents/Sabatico/Examples/Aneur/")

```

# 1. Aortic Aneurysm Progression Data

This dataset contains longitudinal measurements of grades of aortic aneurysms, measured by ultrasound examination of the diameter of the aorta.

A data frame containing 4337 rows, with each row corresponding to an ultrasound scan from one of 838 men over 65 years of age.


* ptnum	(numeric)	Patient identification number   

* age	(numeric)	Recipient age at examination (years)  

* diam	(numeric)	Aortic diameter   

* state	(numeric)	State of aneurysm.   


The states represent successive degrees of aneurysm severity, as indicated by the aortic diameter.

* State 1	Aneurysm-free	< 30 cm  

* State 2	Mild aneurysm	30-44 cm  

* State 3	Moderate aneurysm	45-54 cm  

* State 4	Severe aneurysm	> 55 cm  


683 of these men were aneurysm-free at age 65 and were re-screened every two years. The remaining men were aneurysmal at entry and had successive screens with frequency depending on the state of the aneurysm. Severe aneurysms are repaired by surgery.


```{r, echo=TRUE, eval=TRUE, fig.show="hold", include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
data(aneur)
attach(aneur)
head(aneur)
tail(aneur)
#help(aneur)
dim(aneur)

(N = n_distinct(aneur$ptnum))   # subjects
(K = max(table(aneur$ptnum)))   # times
table(table(aneur$ptnum))

J = 4   # categories
Y_diam = array(NA,dim=c(N,K)) 
Y_state = array(NA,dim=c(N,K))
X_age = array(NA,dim=c(N,K)) 
Ki = table(aneur$ptnum)
Ni = c(0,cumsum(Ki))+1
for(i in 1:N){
	aneur_i = aneur[aneur$ptnum==i,]
	for(k in 1:Ki[i]){
		Y_diam[i,k] = aneur_i$diam[k] 
		Y_state[i,k] = aneur_i$state[k]
		X_age[i,k] = aneur_i$age[k]   
	}  
} 
```

```{r, echo=TRUE, eval=TRUE, fig.show="hold", include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
(Y_diam[11:18,1:8])
(Y_state[11:18,1:8]) 
(X_age[11:18,1:8]) 
(Ki[11:18]) 
```


```{r eval=TRUE, echo=TRUE, fig.show="hold", message=FALSE, warning=FALSE, include=TRUE, out.width="100%"}
### Considering only data having more than one screen (state>1)
idx2 = c()
for(i in 1:N){
  if( sum(Y_state[i,1:Ki[i]])>Ki[i]){
    idx2 = c(idx2,i) 
  }
}
Y2_diam = Y_diam[idx2,]
Y2_state = Y_state[idx2,] 
X2_age = X_age[idx2,]
N2 = length(idx2)
Ki2 = Ki[idx2]

### Considering only data having more than one screen (diam!=29, or diam<29 & dim>29)
idx3 = c()
for(i in 1:N){
  if( min(Y_diam[i,1:Ki[i]])!=max(Y_diam[i,1:Ki[i]])){
    idx3 = c(idx3,i) 
  }
}
Y3_diam = Y_diam[idx3,]
Y3_state = Y_state[idx3,] 
X3_age = X_age[idx3,]
N3 = length(idx3)
Ki3 = Ki[idx3]

aneur2 = aneur%>%filter(aneur$ptnum%in%idx2)
aneur3 = aneur%>%filter(aneur$ptnum%in%idx3)
### Creo que es mejor trabajar con aneur3
```


```{r, echo=FALSE, include=TRUE, evaluate=TRUE} 
### paper size A9: 3.7 x 5.2 cm 

plot(0, type="n", 
     xlim=c(min(X2_age[,],na.rm=TRUE),max(X2_age[,],na.rm=TRUE)), 
     ylim=c(min(Y2_diam[,],na.rm=TRUE),max(Y2_diam[,],na.rm=TRUE)), 
     xlab="Age at examination",ylab="Aortic diameter (mm)")
#plot(0, xlim=c(60,79.5), ylim=c(10,63), type="n", xlab="Age at examination",ylab="Aortic diameter (mm)")

abline(h=c(30,45,55),lty=2,lwd=2)
text(61.5,25,"Stage 1")
text(61.5,37,"Stage 2")
text(61.5,50,"Stage 3")
text(61.5,59,"Stage 4")

points(X2_age[67,],Y2_diam[67,], pch=19,cex=0.8,col="red")
lines(X2_age[67,],Y2_diam[67,], lwd=1.5,col="red")
points(X2_age[80,],Y2_diam[80,], pch=17,cex=0.8,col="magenta")
lines(X2_age[80,],Y2_diam[80,], lwd=1.5,col="magenta")
points(X2_age[119,],Y2_diam[119,], pch=15,cex=0.8,col="blue")
lines(X2_age[119,],Y2_diam[119,], lwd=1.5,col="blue")

Ki[c(67,80,119)]

legend("bottom",c("Subject 690","Subject 705","Subject 746"),pch=c(19,17,15),col=c("red","magenta","blue"),lty=1,ncol=3,cex=0.8)
       
```


```{r, echo=FALSE} 
### paper size A9: 3.7 x 5.2 cm 

ggplot(data=aneur, 
       mapping=aes(x=age,y=diam,group=ptnum)) + 
  geom_line(color=aneur$ptnum) +
  theme_bw() +
  xlab("Age at examination in years") + ylab("Aortic diameter in mm") + ggtitle("Profiles aortic diameter by patient")  

ggplot(data=aneur, 
       mapping=aes(x=age,y=state,group=ptnum)) + 
  geom_line(color=aneur$ptnum) +
    theme_bw() +
  xlab("Age at examination in years") + ylab("States of aneurysm severity") + ggtitle("Profiles states of aneurysm severity by patient")  

```



```{r, echo=FALSE} 
### paper size A9: 3.7 x 5.2 cm 

ggplot(data=aneur3, 
       mapping=aes(x=age,y=diam,group=ptnum)) + 
  geom_line(color=aneur3$ptnum) +
  theme_bw() +
  xlab("Age at examination in years") + ylab("Aortic diameter in mm") + ggtitle("Profiles aortic diameter by patient")  

ggplot(data=aneur3, 
       mapping=aes(x=age,y=state,group=ptnum)) + 
  geom_line(color=aneur3$ptnum) +
    theme_bw() +
  xlab("Age at examination in years") + ylab("States of aneurysm severity") + ggtitle("Profiles states of aneurysm severity by patient")  

```


La variable respuesta puede ser  continua (''diam'') u ordinal (''state''), y la unica covariable es la edad (''age'') \\ 
\begin{eqnarray*}
diam_{it} &=& \beta_0 + f_1(age_{it}) + b_{0i} + age_{it} \times b_{1i} + \varepsilon_{it}, 
\qquad 
\boldsymbol{b}_i\sim\mathrm{N}(\boldsymbol{0},\boldsymbol{\psi}), 
\quad 
\boldsymbol{\varepsilon}_i\sim\mathrm{N}(\boldsymbol{0},\boldsymbol{\Lambda}\sigma^2)  ,
\end{eqnarray*}
where $f_1$ is a non-decreasing smoothing function and $b_{1i}>0$. 


Quiza solo debemos considerar intercepto fijo, pero NO intercepto aleatorio, y SI pendiente aleatorio 
\begin{eqnarray*}
diam_{it} &=& \beta_0 + f_1(age_{it}) +age_{it} \times b_{1i} + \varepsilon_{it}, 
\qquad 
b_{1i}\sim\mathrm{N}(0,\psi), 
\quad 
\boldsymbol{\varepsilon}_i\sim\mathrm{N}(\boldsymbol{0},\boldsymbol{\Lambda}\sigma^2)  ,
\end{eqnarray*}



The ordinal response $state_{it}$ is modelled in terms of the cumulative probabilities $P(state_{it} \leq j | \boldsymbol{b}_i)$ by using the proportional odds model,  
 \begin{eqnarray*}
 P(state_{it} \leq j | \boldsymbol{b}_i) &=& \eta_{it,j}, 
 \end{eqnarray*}
 subject to 
\begin{eqnarray*}
\eta_{it,j} &=& \kappa_{j} + \beta_0 + f_1(age_{it}) +age_{it} \times b_{1i} , 
\qquad 
b_{1i}\sim\mathrm{N}(0,\psi), 
\end{eqnarray*}
where the constraints are such that $f_1$ is a non-decreasing smoothing function and $b_{1i}>0$, and for the breakpoints $\kappa_{j}<\kappa_{j+1}$ with $j=1,2$. 


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}

y = aneur3$state
y_fact = factor(aneur3$state)
x1 = aneur3$age -60 
x2 = aneur3$age -60 
id = as.numeric(as.factor(aneur3$ptnum))
id_fact = as.factor(aneur3$ptnum)

n = length(y)
N = n_distinct(id)
Ni = c(0,cumsum(table(id)))+1
k1 = 3 # 
k2 = 3 # 
knots1 = quantile(x1, c(0.50))
knots2 = quantile(x2, c(0.50))

```


\clearpage

# 2. Generar la matriz diseño $X$ para los B-splines

Note que $f(x)$ se representa como: 
\begin{eqnarray*}
f(x) &=& f_1(x_1)   \\ 
&=& \sum_{j=1}^{h_1} \beta_{1j}\boldsymbol{I}_{1j}(x)   
\end{eqnarray*} 
para $\beta_{1j}$  parámetros desconocidos,
y para los $\boldsymbol{I}_{1j}(x)$  se utilizar\'an I-splines y B-splines.

El número de knots se elige lo suficientemente grande para evitar **over-smoothing**, pero lo suficientemente pequeño para evitar excesivo costo computacional.

El número de $knots$ $K$ es considerado a priori. 


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
# Generate a basis matrix for Natural Cubic Splines 
X2 <- ns(x = x2, knots = knots2, intercept = TRUE) 
###X2 = (X2-mean(X2))/sd(X2) 
matplot(x2, X2) 
```

\clearpage

# 3. Generar la matriz diseño $XI1$ para los I-splines


```{=tex}
\begin{eqnarray*}
f_1(x_1)&&\sum_{j=1}^{h_1} \beta_{1j}\boldsymbol{I}_{1j}(x_1)  \\
\boldsymbol{I}_{1j}(x_1) &=& \int_{x_0}^{x_1} \boldsymbol{B}_{1j}(u) d_{u}
\end{eqnarray*}
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
### ibs: integrated basis splines 
### degree = 3 cubic splines
XI1 <- ibs(x1, knots = knots1, degree = 1, intercept = TRUE) 
###XI1 = (XI1-mean(XI1))/sd(XI1) 
matplot(x1, XI1)
abline(v = knots1, h = knots1, lty = 2, col = "gray") 
```

\clearpage

# 4. Definir la penalización $S1$ y $S2$

La flexibilidad ajustada de $f$ es controlada por  $K$, a través de una penalización cuadrátrica de la forma:  
\begin{eqnarray*}
\sum_{j} \lambda_j \boldsymbol{\beta}^{T} \boldsymbol{S}_j \boldsymbol{\beta} 
\end{eqnarray*}
donde los  $\boldsymbol{S}_j$ son matrices de coeficientes conocidos, y los $\lambda_j$ son parámetros de suavizamiento estimados. 

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
#Este es el código que produce la matriz de diferenciación.  
#No es el óptimo, pero funciona.  
#“k” es el número de b-splines y 
#“d” el orden de la diferenciación. 
#Adjunto el artículo donde discutimos esto (página 7).

diffMatrix = function(k, d = 2){
  if( (d<1) || (d %% 1 != 0) )stop("d must be a positive integer value"); 
  if( (k<1) || (k %% 1 != 0) )stop("k must be a positive integer value"); 
  if(d >= k)stop("d must be lower than k"); 
  out = diag(k); 
  for(i in 1:d){ 
    out = diff(out); 
  } 
  return(out) 
} 
(D1 = diffMatrix(k=k1, d=2))
(D2 = diffMatrix(k=k2, d=2))
(S1 = t(D1)%*%D1 + diag(1,k1)*10e-4) 
(S2 = t(D2)%*%D2 + diag(1,k2)*10e-4) 
```



\clearpage 

# 5. Lineal NO restricciones

## 5.1 Lineal fit without constraints:


For a fit without constraints:

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE, error=TRUE}
set.seed(123)
# mod.lm <- clm(y_fact ~ x1 )
mod.lm <- polr(y_fact ~ x1 )
summary(mod.lm)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
datos.lin <- list( y = y , 
                  n = length(y) , 
                  x1 = x1 )   
param.lin = c("b1", "kappa")
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
stancode <- readLines("jagam_10_aneur_ordinal_lin_non.stan")
# writeLines(stancode)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
mod <- stan_model(model_code=stancode, 
                                  verbose=TRUE)
fit.lin.non <- sampling(mod, 
                                data=datos.lin, 
                                chains=3,warmup=300,iter=600,thin=2,cores=4 ) 
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
print(fit.lin.non, pars=param.lin) 
stan_trace(fit.lin.non,pars=param.lin)
stan_dens(fit.lin.non,pars=param.lin) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lin.non, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lin.non,"mu")
plot(x1,mu[,"mean-all chains"])
```

\clearpage

## 5.2 LME: Lineal fit without constraints:

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
set.seed(123)

#mod.lme <- clmm( y_fact  ~ x1  + (1|id_fact) )

mod.lme <- clmm2( y_fact  ~ x1 , random=id_fact,
                  Hess=TRUE)
summary(mod.lme)

```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
datos.lme <- list( y = y , 
                  n = length(y) , N = N , Ni = Ni, 
                  x1 = x1 , id = id )  
param.lme = c("b1", "kappa", "invsig2","sig2","sigma")
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
stancode <- readLines("jagam_10_aneur_ordinal_lme_non_reintrcpt.stan")
# writeLines(stancode)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
mod <- stan_model(model_code=stancode, 
                                  verbose=TRUE)
fit.lme.non.reintrcpt <- sampling(mod, 
                                data=datos.lme, 
                                chains=3,warmup=300,iter=600,thin=2,cores=4 ) 
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
 
print(fit.lme.non.reintrcpt, pars=param.lme) 
stan_trace(fit.lme.non.reintrcpt,pars=param.lme)
stan_dens(fit.lme.non.reintrcpt,pars=param.lme) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.non.reintrcpt, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lme.non.reintrcpt,"mu")
plot(x1,mu[,"mean-all chains"])

```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
stancode <- readLines("jagam_10_aneur_ordinal_lme_non_reslope.stan")
# writeLines(stancode)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
mod <- stan_model(model_code=stancode, 
                                  verbose=TRUE)
fit.lme.non.reslope <- sampling(mod, 
                                data=datos.lme, 
                                chains=3,warmup=300,iter=600,thin=2,cores=4 ) 
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
 
print(fit.lme.non.reslope, pars=param.lme) 
stan_trace(fit.lme.non.reslope,pars=param.lme)
stan_dens(fit.lme.non.reslope,pars=param.lme) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.non.reslope, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lme.non.reslope,"mu")
plot(x1,mu[,"mean-all chains"])

```


\clearpage 

# 6. Lineal creciente

## 6.1. Lineal creciente

For a spline-based fit without constraints:


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
stancode <- readLines("jagam_10_aneur_ordinal_lin_incr.stan")
# writeLines(stancode)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
mod <- stan_model(model_code=stancode, 
                                  verbose=TRUE)
fit.lin.incr <- sampling(mod, 
                                data=datos.lin, 
                                chains=3,warmup=300,iter=600,thin=2,cores=4 ) 
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
print(fit.lin.incr, pars=param.lin) 
stan_trace(fit.lin.incr,pars=param.lin)
stan_dens(fit.lin.incr,pars=param.lin)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lin.incr, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lin.incr,"mu")
plot(x1,mu[,"mean-all chains"])

```


\clearpage

## 6.2. LME: Lineal creciente

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.incr.reintrcpt <- stan("jagam_10_aneur_ordinal_lme_incr_reintrcpt.stan",
            data=datos.lme,
            chains=3,warmup=300,iter=600,thin=2,cores=4 ) 

print(fit.lme.incr.reintrcpt, pars=param.lme) 
stan_trace(fit.lme.incr.reintrcpt,pars=param.lme)
stan_dens(fit.lme.incr.reintrcpt,pars=param.lme)

```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.incr.reintrcpt, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lme.incr.reintrcpt,"mu")
plot(x1,mu[,"mean-all chains"])

```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.incr.reslope <- stan("jagam_10_aneur_ordinal_lme_incr_reslope.stan",
            data=datos.lme,
            chains=3,warmup=300,iter=600,thin=2,cores=4 ) 

print(fit.lme.incr.reslope, pars=param.lme) 
stan_trace(fit.lme.incr.reslope,pars=param.lme)
stan_dens(fit.lme.incr.reslope,pars=param.lme)

```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.incr.reslope, pars = c("kappa","b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu=get_posterior_mean(fit.lme.incr.reslope,"mu")
plot(x1,mu[,"mean-all chains"])

```





\clearpage 

# 7. Spline NO restricciones

## 7.1 For a spline-based fit without constraints:

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
#set.seed(123)
#mod.s <- cgam(y ~  s(x1) )
#summary(mod.s)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
datos.add.non <- list(  y = y , 
               n = length(y) , k1=k1,
              XI1 = XI1,    
              zero = rep(0,1+k1), 
              S1=S1  )  

inits.add.non <- function(){	list( 
  "b1" = rnorm(k1,0,0.1) ,
  "lambda" = rgamma(1,1,1) 
  )	}

param.add = c("b1", "kappa", "lambda","rho")
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}

fit.add.non <- stan("jagam_10_aneur_ordinal_add_non.stan",
            data=datos.add.non,         
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.add.non) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
print(fit.add.non, pars=param.add) 
stan_trace(fit.add.non, pars=param.add)
stan_plot(fit.add.non, pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.add.non, pars=c("kappa", "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.add.non, pars=c("b1"))
stan_dens(fit.add.non, pars=c("kappa", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.add.non, pars = c("b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="50%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.add.non,"mu1")
plot(x1, mu1[,"mean-all chains"])

```


\clearpage 


## 7.2 LME: For a spline-based fit without constraints:


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
set.seed(123)
mod.lme.s <- gamm( y ~  s(x1,k=5) , random=list(id=~1), correlation=corAR1() )
mod.lme.s
summary(mod.lme.s$lme)
summary(mod.lme.s$gam)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
set.seed(123)
mod.lme.s <- gamm( y ~  s(x1,k=5) , random=list(id=~0+x1), correlation=corAR1() )
mod.lme.s
summary(mod.lme.s$lme)
summary(mod.lme.s$gam)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE, error=TRUE}
set.seed(123)
mod.lme.s <- clmm2( y_fact ~  XI1 , random=id_fact, 
                    Hess=TRUE)
mod.lme.s
summary(mod.lme.s)

```










```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
datos.lme.add.non <- list( y = y , 
                          id = id ,
               n = length(y) , 
               N = N , Ni = Ni,
               k1=k1,  
              XI1 = XI1,  
              x1 = x1, 
              zero = rep(0,1+k1), 
              S1=S1  )  
inits.lme.add.non <- function(){	list( 
  "b1" = rnorm(k1,0,0.1) ,
  "lambda" = rgamma(1,1,1) ,
  "invsig2" = rgamma(1,1,1) ,
  "bre0" = rnorm(N,0,0.1)
  )	}
param.lme.add = c("b1", "kappa", "lambda","rho", "invsig2","sig2","sigma")
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.add.non.reintrcpt <- stan("jagam_10_aneur_ordinal_lme_add_non_reintrcpt.stan",
            data=datos.lme.add.non,
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.lme.add.non) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
print(fit.lme.add.non.reintrcpt, pars=param.lme.add) 
stan_trace(fit.lme.add.non.reintrcpt, pars=param.lme.add)
stan_plot(fit.lme.add.non.reintrcpt, pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.lme.add.non.reintrcpt, pars=c("kappa", "invsig2","sig2","sigma",  "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.lme.add.non.reintrcpt, pars=c("b1"))
stan_dens(fit.lme.add.non.reintrcpt, pars=c("kappa", "invsig2","sig2","sigma", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.add.non.reintrcpt, pars = c("b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.lme.add.non.reintrcpt,"mu1")
plot(x1,mu1[,"mean-all chains"]) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu2 = get_posterior_mean(fit.lme.add.non.reintrcpt,"mu2")
plot(x1,mu2[,"mean-all chains"]) 
```



```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.add.non.reslope <- stan("jagam_10_aneur_ordinal_lme_add_non_reslope.stan",
            data=datos.lme.add.non,
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.lme.add.non) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
print(fit.lme.add.non.reslope, pars=param.lme.add) 
stan_trace(fit.lme.add.non.reslope, pars=param.lme.add)
stan_plot(fit.lme.add.non.reslope, pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.lme.add.non.reslope, pars=c("kappa", "invsig2","sig2","sigma",  "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.lme.add.non.reslope, pars=c("b1"))
stan_dens(fit.lme.add.non.reslope, pars=c("kappa", "invsig2","sig2","sigma", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.add.non.reslope, pars = c("b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.lme.add.non.reslope,"mu1")
plot(x1,mu1[,"mean-all chains"]) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu2 = get_posterior_mean(fit.lme.add.non.reslope,"mu2")
plot(x1,mu2[,"mean-all chains"]) 
```


\clearpage

# 8. Spline con restricciones creciente

## 8.1. LIN: Spline con restricciones creciente

We can model the relationship using I-spline basis functions:



```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}

datos.add.incr <- list( y = y , 
               n = length(y) , k1=k1, 
              XI1 = XI1,   
              zero = rep(0,1+k1), 
              S1=S1  )  

inits.add.incr <- function(){	list( 
  "b1" = abs(rnorm(k1,0,0.1)) ,
  "lambda" = rgamma(1,1,1) 
  )	}

```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.add.incr <- stan("jagam_10_aneur_ordinal_add_incr.stan",
            data=datos.add.incr,
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.add.incr )  

print(fit.add.incr, pars=param.add) 
stan_trace(fit.add.incr,pars=param.add)
stan_plot(fit.add.incr,pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.add.incr,pars=c("kappa", "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.add.incr,pars=c("b1"))
stan_dens(fit.add.incr,pars=c("kappa", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.add.incr, pars = c("b1"), las = 1)
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.add.incr,"mu1")
plot(x1,mu1[,"mean-all chains"])
```


\clearpage 

## 8.2. LME: Spline con restricciones creciente


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
datos.lme.add.incr <- list( y = y , 
                          id = id ,
               n = length(y) , 
               N = N , Ni = Ni,
               k1=k1, 
              XI1 = XI1, 
              x1 = x1, 
              zero = rep(0,1+k1), 
              S1=S1  )  
inits.lme.add.incr <- function(){	list( 
  "b1" = abs(rnorm(k1,0,0.1)),  
  "lambda" = rgamma(1,1,1) ,
  "invsig2" = rgamma(1,1,1) 
  )	} 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.add.incr.reintrcpt <- stan("jagam_10_aneur_ordinal_lme_add_incr_reintrcpt.stan",
            data=datos.lme.add.incr,
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.lme.add.incr) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
print(fit.lme.add.incr.reintrcpt, pars=param.lme.add) 
stan_trace(fit.lme.add.incr.reintrcpt, pars=param.lme.add)
stan_plot(fit.lme.add.incr.reintrcpt, pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.lme.add.incr.reintrcpt, pars=c("kappa", "invsig2","sig2","sigma",  "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.lme.add.incr.reintrcpt, pars=c("b1"))
stan_dens(fit.lme.add.incr.reintrcpt, pars=c("kappa", "invsig2","sig2","sigma", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.add.incr.reintrcpt, pars = c("b1"), las = 1)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.lme.add.incr.reintrcpt,"mu1")
plot(x1,mu1[,"mean-all chains"])
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu2 = get_posterior_mean(fit.lme.add.incr.reintrcpt,"mu2")
plot(x1,mu2[,"mean-all chains"])
```




```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE} 
fit.lme.add.incr.reslope <- stan("jagam_10_aneur_ordinal_lme_add_incr_reslope.stan",
            data=datos.lme.add.incr,
            chains=3,warmup=300,iter=600,thin=2,cores=4,
            init= inits.lme.add.incr) 
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
print(fit.lme.add.incr.reslope, pars=param.lme.add) 
stan_trace(fit.lme.add.incr.reslope, pars=param.lme.add)
stan_plot(fit.lme.add.incr.reslope, pars=c("b1"), point_est = "mean", show_density = TRUE)
stan_plot(fit.lme.add.incr.reslope, pars=c("kappa", "invsig2","sig2","sigma",  "lambda","rho"), point_est = "mean", show_density = TRUE)
stan_dens(fit.lme.add.incr.reslope, pars=c("b1"))
stan_dens(fit.lme.add.incr.reslope, pars=c("kappa", "invsig2","sig2","sigma", "lambda","rho"))
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
pairs(fit.lme.add.incr.reslope, pars = c("b1"), las = 1)
```


```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu1 = get_posterior_mean(fit.lme.add.incr.reslope,"mu1")
plot(x1,mu1[,"mean-all chains"])
```

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=FALSE, message=FALSE}
mu2 = get_posterior_mean(fit.lme.add.incr.reslope,"mu2")
plot(x1,mu2[,"mean-all chains"])
```



# Comparar

```{R, eval=TRUE, fig.show="hold", echo=TRUE, include=TRUE, out.width="100%", warning=TRUE, message=TRUE} 
### http://ritsokiguess.site/docs/2019/06/25/going-to-the-loo-using-stan-for-model-comparison/
library(loo)  

loo1_sample = fit.lin.non
loo2_sample = fit.lme.non.reintrcpt
loo3_sample = fit.lme.non.reslope
loo4_sample = fit.lin.incr
loo5_sample = fit.lme.incr.reintrcpt
loo6_sample = fit.lme.incr.reslope
loo7_sample = fit.add.non
loo8_sample = fit.lme.add.non.reintrcpt
loo9_sample = fit.lme.add.non.reslope
loo10_sample = fit.add.incr
loo11_sample = fit.lme.add.incr.reintrcpt
loo12_sample = fit.lme.add.incr.reslope

### we have to extract those log-likelihood terms that we so carefully had Stan calculate for us:
log_lik_1 =extract_log_lik(loo1_sample, merge_chains = F)
log_lik_2 =extract_log_lik(loo2_sample, merge_chains = F)
log_lik_3 =extract_log_lik(loo3_sample, merge_chains = F)
log_lik_4 =extract_log_lik(loo4_sample, merge_chains = F)
log_lik_5 =extract_log_lik(loo5_sample, merge_chains = F)
log_lik_6 =extract_log_lik(loo6_sample, merge_chains = F)
log_lik_7 =extract_log_lik(loo7_sample, merge_chains = F)
log_lik_8 =extract_log_lik(loo8_sample, merge_chains = F)
log_lik_9 =extract_log_lik(loo9_sample, merge_chains = F)
log_lik_10 =extract_log_lik(loo10_sample, merge_chains = F)
log_lik_11 =extract_log_lik(loo11_sample, merge_chains = F)
log_lik_12 =extract_log_lik(loo12_sample, merge_chains = F)

r_eff_1 =relative_eff(log_lik_1)
r_eff_2 =relative_eff(log_lik_2)
r_eff_3 =relative_eff(log_lik_3)
r_eff_4 =relative_eff(log_lik_4)
r_eff_5 =relative_eff(log_lik_5)
r_eff_6 =relative_eff(log_lik_6)
r_eff_7 =relative_eff(log_lik_7)
r_eff_8 =relative_eff(log_lik_8)
r_eff_9 =relative_eff(log_lik_9)
r_eff_10 =relative_eff(log_lik_10)
r_eff_11 =relative_eff(log_lik_11)
r_eff_12 =relative_eff(log_lik_12)

###  look at the results for each model, first the one with mu estimated:
(loo_1 <- loo(log_lik_1, r_eff=r_eff_1))
(loo_2 <- loo(log_lik_2, r_eff=r_eff_2))
(loo_3 <- loo(log_lik_3, r_eff=r_eff_3))
(loo_4 <- loo(log_lik_4, r_eff=r_eff_4))
(loo_5 <- loo(log_lik_5, r_eff=r_eff_5))
(loo_6 <- loo(log_lik_6, r_eff=r_eff_6))
(loo_7 <- loo(log_lik_7, r_eff=r_eff_7))
(loo_8 <- loo(log_lik_8, r_eff=r_eff_8))
(loo_9 <- loo(log_lik_9, r_eff=r_eff_9))
(loo_10 <- loo(log_lik_10, r_eff=r_eff_10))
(loo_11 <- loo(log_lik_11, r_eff=r_eff_11))
(loo_12 <- loo(log_lik_12, r_eff=r_eff_12))

#compare(loo_1, loo_2)

### The second model fits better than the first one, since its looic is smaller.
```


